---
description: 
globs: 
alwaysApply: false
---
# Cursor Project Rules for LockIn-Bot

You are an expert in Go, microservices architecture, and clean backend development practices, with a specialization in creating robust Discord bots. Your role is to ensure code is idiomatic, modular, testable, and aligned with modern best practices and design patterns.

## 1. Project Overview
- **Project Name:** LockIn-Bot
- **Primary Goal:** **A Discord bot for gamifying studying. To motivate to study or Lock in**
- **Core Functionality:** **
**

## 2. Technical Stack & Versions
- **Go Version:** 1.24.1
- **Primary Database:** PostgreSQL **(version 17)**
- **Key External Services/APIs:** Discord API, **[Neon Database, Render, UptimeRobot]**
- **Containerization:** Docker (see Dockerfile)

## 3. Architecture Principles
- Apply **Clean Architecture** by structuring code into handlers/controllers (e.g., Discord command handlers), services/use cases, repositories/data access, and domain models.
- Consider **domain-driven design (DDD)** principles for complex parts of the bot's logic.
- Prioritize **interface-driven development** with explicit dependency injection (DI).
- Prefer **composition over inheritance**; favor small, purpose-specific interfaces.
- Ensure that all public functions and methods interact with interfaces, not concrete types, to enhance flexibility and testability.
- Keep business logic decoupled from framework-specific code (e.g., Discord library specifics).

## 4. Coding Conventions & Style
- **Formatting:** Standard `gofmt` and `goimports`.
- **Linting:** **golangci-lint with .golangci.yml (recommended, create if not present)**. Enforce naming consistency.
- **Naming Conventions:**
    - Packages: lowercase, short
    - Variables: camelCase
    - Functions: PascalCase for exported, camelCase for unexported
    - Structs: PascalCase
- **Development Best Practices:**
    - Write **short, focused functions** with a single responsibility.
    - Avoid **global state**; use constructor functions or DI to inject dependencies.
    - Leverage **Go's `context.Context` propagation** for request-scoped values (e.g., per Discord command), deadlines, and cancellations.
    - **Defer closing resources** (e.g., database connections, file handles) and handle errors from `Close()` methods where appropriate.
- **Error Handling:**
    - Always **check and handle errors explicitly**.
    - Wrap errors with `fmt.Errorf("module: operation failed: %w", err)` for context and traceability.
    - **Consider defining custom error types in `internal/errors/errors.go` for specific, well-known error conditions.**
- **Logging:**
    - **Use a structured logging library like `logrus` or `zap` (recommended).**
    - Log levels to use: INFO for general events, ERROR for issues, DEBUG for development-time diagnostics.
    - Include context (e.g., trace ID, command name, user ID) in logs.

## 5. Directory Structure & Code Organization
- Use a consistent project layout:
    - **`cmd/lockin-bot/`:** Main application entry point for the bot.
    - **`internal/`:** Core application logic (not exposed externally).
        - **`internal/bot/`:** Core bot logic, Discord command handlers, event processors.
        - **`internal/service/`:** Business logic and use cases.
        - **`internal/repository/`:** Data access logic (interfaces and implementations).
        - **`internal/domain/` or `internal/models/`:** Core domain models/structs.
        - **`internal/config/`:** Configuration loading (e.g., using Viper).
        - **`internal/database/`:** SQLC generated database access code.
    - **`pkg/`:** Shared utilities and packages (if any are intended to be used by other potential projects).
    - **`api/`:** **[Optional: gRPC/REST transport definitions if the bot exposes other APIs. For Discord interactions, this might map to command definitions.]**
    - **`configs/`:** **[Optional: Configuration schema files or templates if not handled solely by env vars/Viper struct.]**
    - **`db/`:**
        - **`db/query/` (actually `db/queries.sql`):** SQL query files for SQLC.
        - **`db/migrations/`:** Database migration files (e.g., for `pressly/goose`).
        - **`db/schema.sql`:** Database schema definition (snapshot or initial setup).
    - **`test/`:** **[Optional: Test utilities, mocks, and integration test setup shared across packages.]**
- Group code by feature within `internal/` subdirectories when it improves clarity and cohesion.
- **`sqlc.yaml`:** Configuration for SQLC.
- **`Dockerfile`:** Defines the build and runtime environment.
- **`main.go` (likely in `cmd/lockin-bot/`):** Main application entry point.

## 6. Build & Deployment
- **Build Command:** `CGO_ENABLED=0 GOOS=linux go build -a -ldflags "-s -w" -o /app/lockin-bot ./cmd/lockin-bot/main.go` (inside Docker) or `docker build -t lockin-bot .`
- **Runtime Environment:** Defined in `Dockerfile`. Base image: `alpine:latest`.
- **Deployment Notes:** **[Environment variable setup on Render, Neon DB connection strings, UptimeRobot configuration.]**
- Integrate **linting, testing, and security checks** in CI/CD pipelines.
- Automate workflows for testing, building, and deployment.

## 7. Dependencies (`go.mod`)
- **Management:** Via Go Modules (`go.mod`, `go.sum`). Ensure version-locking for deterministic builds.
- **Adding New Dependencies:** Discuss with team, ensure license compatibility, prefer established, stable, minimal third-party libraries. Prefer the standard library where feasible.

## 8. Database (using SQLC)
- **SQLC Config:** `sqlc.yaml`
- **Schema File Source for SQLC:** `db/migrations` (SQLC uses migration files as schema source)
- **Query Files:** `db/queries.sql`
- **Generated Code Location:** `internal/database` (package `database`)
- **Process for Changes:**
    1. Add/modify SQL files in `db/migrations/` for schema changes.
    2. Add/modify SQL query files in `db/queries.sql` for new queries.
    3. Run `sqlc generate`.
    4. Run database migrations (e.g., `goose up` via a script or makefile).

## 9. API Design (Discord Commands)
- **Command Structure (Discord):** **[e.g., Slash commands preferred via discordgo interaction handlers. Define clear input parameters and responses.]**
- **Error Responses:** **[Consistent user-facing error messages for commands (e.g., "Sorry, something went wrong!"), log detailed errors internally with context.]**

## 10. Testing
- **Framework:** Standard Go `testing` package.
- Write **unit tests** using table-driven patterns where appropriate. Run tests in parallel (`t.Parallel()`) when safe.
- **Mock external dependencies** (like Discord API interactions, database calls) cleanly. Use interfaces for all dependencies to allow mocking. SQLC `emit_interface: true` is helpful here. Consider using `gomock` or writing manual mocks.
- Separate **fast unit tests** from slower **integration tests** (e.g., using build tags or naming conventions).
- Aim for **high test coverage** for every exported function and critical logic path, with behavioral checks.
- Use tools like `go test -cover -coverprofile=coverage.out && go tool cover -html=coverage.out` to analyze coverage.
- Place tests in `_test.go` files alongside the code they test. Shared test utilities can go in `internal/testutil` or `test/`.

## 11. Security and Resilience
- Apply **input validation and sanitization** rigorously on all inputs (Discord command arguments, API responses if calling external services).
- Store **secrets securely** (Discord bot token, database credentials) using environment variables, loaded via Viper, and never commit them to the repository.
- Be mindful of **Discord API rate limits**. Implement appropriate backoff and retry mechanisms for API calls (`github.com/sethvargo/go-retry` or similar).
- Use **timeouts** on all external calls (Discord API, database).
- Consider **circuit breakers** for critical external dependencies if the bot becomes complex.
- **Isolate sensitive operations** with clear permission checks within the bot (e.g., admin-only commands).
- **[If applicable: Use secure defaults for JWT, cookies, if the bot has an associated web interface/API.]**

## 12. Concurrency Best Practices
- Use **goroutines safely**. Guard shared state with channels, mutexes (`sync.Mutex`, `sync.RWMutex`), or other `sync` primitives.
- Implement **goroutine cancellation** using `context.Context` propagation to prevent leaks and ensure graceful shutdown.
- Be mindful of potential deadlocks and race conditions; use the race detector (`go test -race`).

## 13. Performance Guidelines
- Write **benchmarks** (`_test.go` files with `BenchmarkXxx` functions) for performance-critical code paths.
- Minimize **memory allocations** in hot paths.
- **Profile before optimizing.** Use Go's built-in profiling tools (`pprof`) to identify bottlenecks.
-

## 15. Documentation and Standards
- Document all public functions, types, and packages with **GoDoc-style comments**.
- Provide a concise **README.md** for the project, explaining setup, configuration, and how to run the bot.
- Consider a **`CONTRIBUTING.md`** if others will contribute.
- **[Optional: An `ARCHITECTURE.md` file to document high-level design decisions.]**

## 16. Key Project-Specific Rules & Guidelines
- **Configuration Management:** Environment variables preferred, loaded via `github.com/spf13/viper` (from `internal/config`).
- **Data Validation:** Validate all user inputs (Discord command arguments) and external API responses thoroughly.
- **Design for Change:** Isolate business logic from Discord library specifics to ease future migrations or changes.
- Prioritize **readability, simplicity, and maintainability** in all code.
- **Always close database connections/rows properly.**
- **Log errors with sufficient context** to aid debugging.
- **[Add any other critical DOs/DON'Ts specific to LockIn-Bot]** 
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createOrUpdateUserStats = `-- name: CreateOrUpdateUserStats :one
INSERT INTO user_stats (user_id, total_study_ms, daily_study_ms, weekly_study_ms, monthly_study_ms)
VALUES ($1, $2, $2, $2, $2)
ON CONFLICT (user_id) DO UPDATE
SET 
  total_study_ms = user_stats.total_study_ms + $2,
  daily_study_ms = user_stats.daily_study_ms + $2,
  weekly_study_ms = user_stats.weekly_study_ms + $2,
  monthly_study_ms = user_stats.monthly_study_ms + $2
RETURNING user_id, total_study_ms, daily_study_ms, weekly_study_ms, monthly_study_ms, current_streak, max_streak, last_streak_date, streak_freezes
`

type CreateOrUpdateUserStatsParams struct {
	UserID       string        `json:"userId"`
	TotalStudyMs sql.NullInt64 `json:"totalStudyMs"`
}

func (q *Queries) CreateOrUpdateUserStats(ctx context.Context, arg CreateOrUpdateUserStatsParams) (UserStat, error) {
	row := q.db.QueryRowContext(ctx, createOrUpdateUserStats, arg.UserID, arg.TotalStudyMs)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.TotalStudyMs,
		&i.DailyStudyMs,
		&i.WeeklyStudyMs,
		&i.MonthlyStudyMs,
		&i.CurrentStreak,
		&i.MaxStreak,
		&i.LastStreakDate,
		&i.StreakFreezes,
	)
	return i, err
}

const createStudySession = `-- name: CreateStudySession :one
INSERT INTO study_sessions (user_id, start_time)
VALUES ($1, $2)
RETURNING session_id, user_id, start_time, end_time, duration_ms
`

type CreateStudySessionParams struct {
	UserID    sql.NullString `json:"userId"`
	StartTime time.Time      `json:"startTime"`
}

func (q *Queries) CreateStudySession(ctx context.Context, arg CreateStudySessionParams) (StudySession, error) {
	row := q.db.QueryRowContext(ctx, createStudySession, arg.UserID, arg.StartTime)
	var i StudySession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (user_id, username)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE SET username = $2
RETURNING user_id, username
`

type CreateUserParams struct {
	UserID   string         `json:"userId"`
	Username sql.NullString `json:"username"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.UserID, arg.Username)
	var i User
	err := row.Scan(&i.UserID, &i.Username)
	return i, err
}

const endStudySession = `-- name: EndStudySession :one
UPDATE study_sessions
SET end_time = $2, duration_ms = EXTRACT(EPOCH FROM ($2 - start_time)) * 1000
WHERE session_id = $1 AND end_time IS NULL
RETURNING session_id, user_id, start_time, end_time, duration_ms
`

type EndStudySessionParams struct {
	SessionID int32        `json:"sessionId"`
	EndTime   sql.NullTime `json:"endTime"`
}

func (q *Queries) EndStudySession(ctx context.Context, arg EndStudySessionParams) (StudySession, error) {
	row := q.db.QueryRowContext(ctx, endStudySession, arg.SessionID, arg.EndTime)
	var i StudySession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
	)
	return i, err
}

const getActiveStudySession = `-- name: GetActiveStudySession :one
SELECT session_id, user_id, start_time, end_time, duration_ms FROM study_sessions
WHERE user_id = $1 AND end_time IS NULL
LIMIT 1
`

func (q *Queries) GetActiveStudySession(ctx context.Context, userID sql.NullString) (StudySession, error) {
	row := q.db.QueryRowContext(ctx, getActiveStudySession, userID)
	var i StudySession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT user_id, username FROM users
WHERE user_id = $1
`

func (q *Queries) GetUser(ctx context.Context, userID string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, userID)
	var i User
	err := row.Scan(&i.UserID, &i.Username)
	return i, err
}

const getUserStats = `-- name: GetUserStats :one
SELECT user_id, total_study_ms, daily_study_ms, weekly_study_ms, monthly_study_ms, current_streak, max_streak, last_streak_date, streak_freezes FROM user_stats
WHERE user_id = $1
`

func (q *Queries) GetUserStats(ctx context.Context, userID string) (UserStat, error) {
	row := q.db.QueryRowContext(ctx, getUserStats, userID)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.TotalStudyMs,
		&i.DailyStudyMs,
		&i.WeeklyStudyMs,
		&i.MonthlyStudyMs,
		&i.CurrentStreak,
		&i.MaxStreak,
		&i.LastStreakDate,
		&i.StreakFreezes,
	)
	return i, err
}

const resetDailyStudyTime = `-- name: ResetDailyStudyTime :exec
UPDATE user_stats
SET daily_study_ms = 0
`

func (q *Queries) ResetDailyStudyTime(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetDailyStudyTime)
	return err
}

const resetMonthlyStudyTime = `-- name: ResetMonthlyStudyTime :exec
UPDATE user_stats
SET monthly_study_ms = 0
`

func (q *Queries) ResetMonthlyStudyTime(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetMonthlyStudyTime)
	return err
}

const resetWeeklyStudyTime = `-- name: ResetWeeklyStudyTime :exec
UPDATE user_stats
SET weekly_study_ms = 0
`

func (q *Queries) ResetWeeklyStudyTime(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetWeeklyStudyTime)
	return err
}

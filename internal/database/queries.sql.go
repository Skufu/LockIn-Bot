// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createOrUpdateUserStats = `-- name: CreateOrUpdateUserStats :one
INSERT INTO user_stats (user_id, total_study_ms, daily_study_ms, weekly_study_ms, monthly_study_ms)
VALUES ($1, $2, $2, $2, $2)
ON CONFLICT (user_id) DO UPDATE
SET 
  total_study_ms = user_stats.total_study_ms + $2,
  daily_study_ms = user_stats.daily_study_ms + $2,
  weekly_study_ms = user_stats.weekly_study_ms + $2,
  monthly_study_ms = user_stats.monthly_study_ms + $2
RETURNING user_id, total_study_ms, daily_study_ms, weekly_study_ms, monthly_study_ms, current_streak, max_streak, last_streak_date, streak_freezes
`

type CreateOrUpdateUserStatsParams struct {
	UserID       string        `json:"userId"`
	TotalStudyMs sql.NullInt64 `json:"totalStudyMs"`
}

func (q *Queries) CreateOrUpdateUserStats(ctx context.Context, arg CreateOrUpdateUserStatsParams) (UserStat, error) {
	row := q.db.QueryRowContext(ctx, createOrUpdateUserStats, arg.UserID, arg.TotalStudyMs)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.TotalStudyMs,
		&i.DailyStudyMs,
		&i.WeeklyStudyMs,
		&i.MonthlyStudyMs,
		&i.CurrentStreak,
		&i.MaxStreak,
		&i.LastStreakDate,
		&i.StreakFreezes,
	)
	return i, err
}

const createStudySession = `-- name: CreateStudySession :one
INSERT INTO study_sessions (user_id, start_time)
VALUES ($1, $2)
RETURNING session_id, user_id, start_time, end_time, duration_ms
`

type CreateStudySessionParams struct {
	UserID    sql.NullString `json:"userId"`
	StartTime time.Time      `json:"startTime"`
}

func (q *Queries) CreateStudySession(ctx context.Context, arg CreateStudySessionParams) (StudySession, error) {
	row := q.db.QueryRowContext(ctx, createStudySession, arg.UserID, arg.StartTime)
	var i StudySession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (user_id, username)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE SET username = $2
RETURNING user_id, username
`

type CreateUserParams struct {
	UserID   string         `json:"userId"`
	Username sql.NullString `json:"username"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.UserID, arg.Username)
	var i User
	err := row.Scan(&i.UserID, &i.Username)
	return i, err
}

const deleteOldStudySessions = `-- name: DeleteOldStudySessions :exec

DELETE FROM study_sessions
WHERE start_time < $1
`

// For top 10 users
func (q *Queries) DeleteOldStudySessions(ctx context.Context, startTime time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldStudySessions, startTime)
	return err
}

const endStudySession = `-- name: EndStudySession :one
UPDATE study_sessions
SET end_time = $2, duration_ms = EXTRACT(EPOCH FROM ($2 - start_time)) * 1000
WHERE session_id = $1 AND end_time IS NULL
RETURNING session_id, user_id, start_time, end_time, duration_ms
`

type EndStudySessionParams struct {
	SessionID int32        `json:"sessionId"`
	EndTime   sql.NullTime `json:"endTime"`
}

func (q *Queries) EndStudySession(ctx context.Context, arg EndStudySessionParams) (StudySession, error) {
	row := q.db.QueryRowContext(ctx, endStudySession, arg.SessionID, arg.EndTime)
	var i StudySession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
	)
	return i, err
}

const getActiveStudySession = `-- name: GetActiveStudySession :one
/* ACTIVE_SESSION_QUERY_1_PARAM */ SELECT session_id, user_id, start_time, end_time, duration_ms FROM study_sessions
WHERE user_id = $1 AND end_time IS NULL
LIMIT 1
`

func (q *Queries) GetActiveStudySession(ctx context.Context, userID sql.NullString) (StudySession, error) {
	row := q.db.QueryRowContext(ctx, getActiveStudySession, userID)
	var i StudySession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMs,
	)
	return i, err
}

const getLeaderboard = `-- name: GetLeaderboard :many
SELECT
    u.username,
    us.total_study_ms,
    u.user_id -- Also select user_id for mentions
FROM
    user_stats us
JOIN
    users u ON us.user_id = u.user_id
WHERE
    us.total_study_ms > 0 -- Only show users who have studied
ORDER BY
    us.total_study_ms DESC
LIMIT 10
`

type GetLeaderboardRow struct {
	Username     sql.NullString `json:"username"`
	TotalStudyMs sql.NullInt64  `json:"totalStudyMs"`
	UserID       string         `json:"userId"`
}

func (q *Queries) GetLeaderboard(ctx context.Context) ([]GetLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeaderboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaderboardRow
	for rows.Next() {
		var i GetLeaderboardRow
		if err := rows.Scan(&i.Username, &i.TotalStudyMs, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT user_id, username FROM users
WHERE user_id = $1
`

func (q *Queries) GetUser(ctx context.Context, userID string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, userID)
	var i User
	err := row.Scan(&i.UserID, &i.Username)
	return i, err
}

const getUserStats = `-- name: GetUserStats :one
SELECT user_id, total_study_ms, daily_study_ms, weekly_study_ms, monthly_study_ms, current_streak, max_streak, last_streak_date, streak_freezes FROM user_stats
WHERE user_id = $1
`

func (q *Queries) GetUserStats(ctx context.Context, userID string) (UserStat, error) {
	row := q.db.QueryRowContext(ctx, getUserStats, userID)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.TotalStudyMs,
		&i.DailyStudyMs,
		&i.WeeklyStudyMs,
		&i.MonthlyStudyMs,
		&i.CurrentStreak,
		&i.MaxStreak,
		&i.LastStreakDate,
		&i.StreakFreezes,
	)
	return i, err
}

const getUserStreak = `-- name: GetUserStreak :one


SELECT
    user_id,
    guild_id,
    current_streak_count,
    max_streak_count,
    last_activity_date,
    streak_evaluated_date,
    daily_activity_minutes,
    activity_start_time,
    streak_incremented_today,
    warning_notified_at,
    created_at,
    updated_at
FROM user_streaks
WHERE user_id = $1 AND guild_id = $2
`

type GetUserStreakParams struct {
	UserID  string `json:"userId"`
	GuildID string `json:"guildId"`
}

type GetUserStreakRow struct {
	UserID                 string        `json:"userId"`
	GuildID                string        `json:"guildId"`
	CurrentStreakCount     int32         `json:"currentStreakCount"`
	MaxStreakCount         int32         `json:"maxStreakCount"`
	LastActivityDate       sql.NullTime  `json:"lastActivityDate"`
	StreakEvaluatedDate    sql.NullTime  `json:"streakEvaluatedDate"`
	DailyActivityMinutes   sql.NullInt32 `json:"dailyActivityMinutes"`
	ActivityStartTime      sql.NullTime  `json:"activityStartTime"`
	StreakIncrementedToday bool          `json:"streakIncrementedToday"`
	WarningNotifiedAt      sql.NullTime  `json:"warningNotifiedAt"`
	CreatedAt              time.Time     `json:"createdAt"`
	UpdatedAt              time.Time     `json:"updatedAt"`
}

// $1 will be the cutoff timestamp (e.g., 6 months ago)
// Calendar Day-Based User Streaks Queries
func (q *Queries) GetUserStreak(ctx context.Context, arg GetUserStreakParams) (GetUserStreakRow, error) {
	row := q.db.QueryRowContext(ctx, getUserStreak, arg.UserID, arg.GuildID)
	var i GetUserStreakRow
	err := row.Scan(
		&i.UserID,
		&i.GuildID,
		&i.CurrentStreakCount,
		&i.MaxStreakCount,
		&i.LastActivityDate,
		&i.StreakEvaluatedDate,
		&i.DailyActivityMinutes,
		&i.ActivityStartTime,
		&i.StreakIncrementedToday,
		&i.WarningNotifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUsersForDailyEvaluation = `-- name: GetUsersForDailyEvaluation :many
SELECT 
    user_id, 
    guild_id, 
    current_streak_count, 
    max_streak_count, 
    last_activity_date,
    streak_evaluated_date,
    daily_activity_minutes,
    warning_notified_at,
    created_at,
    updated_at
FROM user_streaks
WHERE streak_evaluated_date IS NULL 
   OR streak_evaluated_date < $1
`

type GetUsersForDailyEvaluationRow struct {
	UserID               string        `json:"userId"`
	GuildID              string        `json:"guildId"`
	CurrentStreakCount   int32         `json:"currentStreakCount"`
	MaxStreakCount       int32         `json:"maxStreakCount"`
	LastActivityDate     sql.NullTime  `json:"lastActivityDate"`
	StreakEvaluatedDate  sql.NullTime  `json:"streakEvaluatedDate"`
	DailyActivityMinutes sql.NullInt32 `json:"dailyActivityMinutes"`
	WarningNotifiedAt    sql.NullTime  `json:"warningNotifiedAt"`
	CreatedAt            time.Time     `json:"createdAt"`
	UpdatedAt            time.Time     `json:"updatedAt"`
}

func (q *Queries) GetUsersForDailyEvaluation(ctx context.Context, streakEvaluatedDate sql.NullTime) ([]GetUsersForDailyEvaluationRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersForDailyEvaluation, streakEvaluatedDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersForDailyEvaluationRow
	for rows.Next() {
		var i GetUsersForDailyEvaluationRow
		if err := rows.Scan(
			&i.UserID,
			&i.GuildID,
			&i.CurrentStreakCount,
			&i.MaxStreakCount,
			&i.LastActivityDate,
			&i.StreakEvaluatedDate,
			&i.DailyActivityMinutes,
			&i.WarningNotifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersForStreakReset = `-- name: GetUsersForStreakReset :many
SELECT 
    user_id, 
    guild_id, 
    current_streak_count
FROM user_streaks
WHERE current_streak_count > 0
  AND streak_incremented_today = FALSE
  AND (last_activity_date IS NULL OR last_activity_date < $1)
`

type GetUsersForStreakResetRow struct {
	UserID             string `json:"userId"`
	GuildID            string `json:"guildId"`
	CurrentStreakCount int32  `json:"currentStreakCount"`
}

func (q *Queries) GetUsersForStreakReset(ctx context.Context, lastActivityDate sql.NullTime) ([]GetUsersForStreakResetRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersForStreakReset, lastActivityDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersForStreakResetRow
	for rows.Next() {
		var i GetUsersForStreakResetRow
		if err := rows.Scan(&i.UserID, &i.GuildID, &i.CurrentStreakCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersNeedingWarnings = `-- name: GetUsersNeedingWarnings :many
SELECT 
    user_id, 
    guild_id, 
    current_streak_count, 
    max_streak_count, 
    last_activity_date,
    daily_activity_minutes,
    warning_notified_at,
    created_at,
    updated_at
FROM user_streaks
WHERE current_streak_count > 0
  AND (last_activity_date IS NULL OR last_activity_date < $1) -- Haven't been active today
  AND (warning_notified_at IS NULL OR DATE(warning_notified_at) < $1)
`

type GetUsersNeedingWarningsRow struct {
	UserID               string        `json:"userId"`
	GuildID              string        `json:"guildId"`
	CurrentStreakCount   int32         `json:"currentStreakCount"`
	MaxStreakCount       int32         `json:"maxStreakCount"`
	LastActivityDate     sql.NullTime  `json:"lastActivityDate"`
	DailyActivityMinutes sql.NullInt32 `json:"dailyActivityMinutes"`
	WarningNotifiedAt    sql.NullTime  `json:"warningNotifiedAt"`
	CreatedAt            time.Time     `json:"createdAt"`
	UpdatedAt            time.Time     `json:"updatedAt"`
}

func (q *Queries) GetUsersNeedingWarnings(ctx context.Context, lastActivityDate sql.NullTime) ([]GetUsersNeedingWarningsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersNeedingWarnings, lastActivityDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersNeedingWarningsRow
	for rows.Next() {
		var i GetUsersNeedingWarningsRow
		if err := rows.Scan(
			&i.UserID,
			&i.GuildID,
			&i.CurrentStreakCount,
			&i.MaxStreakCount,
			&i.LastActivityDate,
			&i.DailyActivityMinutes,
			&i.WarningNotifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasActivityForDate = `-- name: HasActivityForDate :one
/* ACTIVITY_CHECK_QUERY_4_PARAM */ SELECT EXISTS(
    SELECT 1 FROM user_streaks 
    WHERE user_id = $1 
    AND guild_id = $2 
    AND last_activity_date = $3 
    AND daily_activity_minutes >= $4
)
`

type HasActivityForDateParams struct {
	UserID               string        `json:"userId"`
	GuildID              string        `json:"guildId"`
	LastActivityDate     sql.NullTime  `json:"lastActivityDate"`
	DailyActivityMinutes sql.NullInt32 `json:"dailyActivityMinutes"`
}

func (q *Queries) HasActivityForDate(ctx context.Context, arg HasActivityForDateParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasActivityForDate,
		arg.UserID,
		arg.GuildID,
		arg.LastActivityDate,
		arg.DailyActivityMinutes,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const resetAllStreakDailyFlags = `-- name: ResetAllStreakDailyFlags :exec
UPDATE user_streaks
SET 
    streak_incremented_today = FALSE,
    updated_at = NOW()
`

func (q *Queries) ResetAllStreakDailyFlags(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetAllStreakDailyFlags)
	return err
}

const resetDailyStudyTime = `-- name: ResetDailyStudyTime :exec
UPDATE user_stats
SET daily_study_ms = 0
`

func (q *Queries) ResetDailyStudyTime(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetDailyStudyTime)
	return err
}

const resetMonthlyStudyTime = `-- name: ResetMonthlyStudyTime :exec
UPDATE user_stats
SET monthly_study_ms = 0
`

func (q *Queries) ResetMonthlyStudyTime(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetMonthlyStudyTime)
	return err
}

const resetUserStreakCount = `-- name: ResetUserStreakCount :exec

UPDATE user_streaks
SET 
    current_streak_count = 0,
    updated_at = NOW()
WHERE user_id = $1 AND guild_id = $2
`

type ResetUserStreakCountParams struct {
	UserID  string `json:"userId"`
	GuildID string `json:"guildId"`
}

// Haven't been active today
func (q *Queries) ResetUserStreakCount(ctx context.Context, arg ResetUserStreakCountParams) error {
	_, err := q.db.ExecContext(ctx, resetUserStreakCount, arg.UserID, arg.GuildID)
	return err
}

const resetWeeklyStudyTime = `-- name: ResetWeeklyStudyTime :exec
UPDATE user_stats
SET weekly_study_ms = 0
`

func (q *Queries) ResetWeeklyStudyTime(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetWeeklyStudyTime)
	return err
}

const startDailyActivity = `-- name: StartDailyActivity :one
INSERT INTO user_streaks (
    user_id, 
    guild_id, 
    current_streak_count,
    max_streak_count,
    last_activity_date,
    daily_activity_minutes,
    activity_start_time,
    streak_incremented_today,
    updated_at
)
VALUES ($1, $2, 0, 0, $3, 0, $4, FALSE, NOW())
ON CONFLICT (user_id, guild_id) DO UPDATE SET
    last_activity_date = CASE 
        WHEN user_streaks.last_activity_date != $3 THEN $3
        ELSE user_streaks.last_activity_date
    END,
    daily_activity_minutes = CASE 
        WHEN user_streaks.last_activity_date != $3 THEN 0
        ELSE user_streaks.daily_activity_minutes
    END,
    activity_start_time = CASE 
        WHEN user_streaks.last_activity_date != $3 THEN $4
        WHEN user_streaks.activity_start_time IS NULL THEN $4
        ELSE user_streaks.activity_start_time
    END,
    streak_incremented_today = CASE 
        WHEN user_streaks.last_activity_date != $3 THEN FALSE
        ELSE user_streaks.streak_incremented_today
    END,
    updated_at = NOW()
RETURNING user_id, guild_id, current_streak_count, max_streak_count, last_activity_date, streak_evaluated_date, daily_activity_minutes, activity_start_time, streak_incremented_today, warning_notified_at, created_at, updated_at
`

type StartDailyActivityParams struct {
	UserID            string       `json:"userId"`
	GuildID           string       `json:"guildId"`
	LastActivityDate  sql.NullTime `json:"lastActivityDate"`
	ActivityStartTime sql.NullTime `json:"activityStartTime"`
}

type StartDailyActivityRow struct {
	UserID                 string        `json:"userId"`
	GuildID                string        `json:"guildId"`
	CurrentStreakCount     int32         `json:"currentStreakCount"`
	MaxStreakCount         int32         `json:"maxStreakCount"`
	LastActivityDate       sql.NullTime  `json:"lastActivityDate"`
	StreakEvaluatedDate    sql.NullTime  `json:"streakEvaluatedDate"`
	DailyActivityMinutes   sql.NullInt32 `json:"dailyActivityMinutes"`
	ActivityStartTime      sql.NullTime  `json:"activityStartTime"`
	StreakIncrementedToday bool          `json:"streakIncrementedToday"`
	WarningNotifiedAt      sql.NullTime  `json:"warningNotifiedAt"`
	CreatedAt              time.Time     `json:"createdAt"`
	UpdatedAt              time.Time     `json:"updatedAt"`
}

func (q *Queries) StartDailyActivity(ctx context.Context, arg StartDailyActivityParams) (StartDailyActivityRow, error) {
	row := q.db.QueryRowContext(ctx, startDailyActivity,
		arg.UserID,
		arg.GuildID,
		arg.LastActivityDate,
		arg.ActivityStartTime,
	)
	var i StartDailyActivityRow
	err := row.Scan(
		&i.UserID,
		&i.GuildID,
		&i.CurrentStreakCount,
		&i.MaxStreakCount,
		&i.LastActivityDate,
		&i.StreakEvaluatedDate,
		&i.DailyActivityMinutes,
		&i.ActivityStartTime,
		&i.StreakIncrementedToday,
		&i.WarningNotifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDailyActivityMinutes = `-- name: UpdateDailyActivityMinutes :exec
UPDATE user_streaks
SET 
    daily_activity_minutes = $3,
    updated_at = NOW()
WHERE user_id = $1 AND guild_id = $2
`

type UpdateDailyActivityMinutesParams struct {
	UserID               string        `json:"userId"`
	GuildID              string        `json:"guildId"`
	DailyActivityMinutes sql.NullInt32 `json:"dailyActivityMinutes"`
}

func (q *Queries) UpdateDailyActivityMinutes(ctx context.Context, arg UpdateDailyActivityMinutesParams) error {
	_, err := q.db.ExecContext(ctx, updateDailyActivityMinutes, arg.UserID, arg.GuildID, arg.DailyActivityMinutes)
	return err
}

const updateStreakImmediately = `-- name: UpdateStreakImmediately :exec
UPDATE user_streaks
SET 
    current_streak_count = $3,
    max_streak_count = GREATEST(max_streak_count, $4),
    streak_incremented_today = TRUE,
    updated_at = NOW()
WHERE user_id = $1 AND guild_id = $2
`

type UpdateStreakImmediatelyParams struct {
	UserID             string `json:"userId"`
	GuildID            string `json:"guildId"`
	CurrentStreakCount int32  `json:"currentStreakCount"`
	MaxStreakCount     int32  `json:"maxStreakCount"`
}

func (q *Queries) UpdateStreakImmediately(ctx context.Context, arg UpdateStreakImmediatelyParams) error {
	_, err := q.db.ExecContext(ctx, updateStreakImmediately,
		arg.UserID,
		arg.GuildID,
		arg.CurrentStreakCount,
		arg.MaxStreakCount,
	)
	return err
}

const updateUserStreakAfterEvaluation = `-- name: UpdateUserStreakAfterEvaluation :one

UPDATE user_streaks
SET 
    current_streak_count = $3,
    max_streak_count = GREATEST(max_streak_count, $4),
    streak_evaluated_date = $5,
    updated_at = NOW()
WHERE user_id = $1 AND guild_id = $2
RETURNING user_id, guild_id, current_streak_count, max_streak_count, last_activity_date, streak_evaluated_date, daily_activity_minutes, activity_start_time, warning_notified_at, created_at, updated_at
`

type UpdateUserStreakAfterEvaluationParams struct {
	UserID              string       `json:"userId"`
	GuildID             string       `json:"guildId"`
	CurrentStreakCount  int32        `json:"currentStreakCount"`
	MaxStreakCount      int32        `json:"maxStreakCount"`
	StreakEvaluatedDate sql.NullTime `json:"streakEvaluatedDate"`
}

type UpdateUserStreakAfterEvaluationRow struct {
	UserID               string        `json:"userId"`
	GuildID              string        `json:"guildId"`
	CurrentStreakCount   int32         `json:"currentStreakCount"`
	MaxStreakCount       int32         `json:"maxStreakCount"`
	LastActivityDate     sql.NullTime  `json:"lastActivityDate"`
	StreakEvaluatedDate  sql.NullTime  `json:"streakEvaluatedDate"`
	DailyActivityMinutes sql.NullInt32 `json:"dailyActivityMinutes"`
	ActivityStartTime    sql.NullTime  `json:"activityStartTime"`
	WarningNotifiedAt    sql.NullTime  `json:"warningNotifiedAt"`
	CreatedAt            time.Time     `json:"createdAt"`
	UpdatedAt            time.Time     `json:"updatedAt"`
}

// $1 is today's date in Manila timezone
func (q *Queries) UpdateUserStreakAfterEvaluation(ctx context.Context, arg UpdateUserStreakAfterEvaluationParams) (UpdateUserStreakAfterEvaluationRow, error) {
	row := q.db.QueryRowContext(ctx, updateUserStreakAfterEvaluation,
		arg.UserID,
		arg.GuildID,
		arg.CurrentStreakCount,
		arg.MaxStreakCount,
		arg.StreakEvaluatedDate,
	)
	var i UpdateUserStreakAfterEvaluationRow
	err := row.Scan(
		&i.UserID,
		&i.GuildID,
		&i.CurrentStreakCount,
		&i.MaxStreakCount,
		&i.LastActivityDate,
		&i.StreakEvaluatedDate,
		&i.DailyActivityMinutes,
		&i.ActivityStartTime,
		&i.WarningNotifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWarningNotifiedAt = `-- name: UpdateWarningNotifiedAt :exec

UPDATE user_streaks
SET 
    warning_notified_at = $3,
    updated_at = NOW()
WHERE user_id = $1 AND guild_id = $2
`

type UpdateWarningNotifiedAtParams struct {
	UserID            string       `json:"userId"`
	GuildID           string       `json:"guildId"`
	WarningNotifiedAt sql.NullTime `json:"warningNotifiedAt"`
}

// Haven't been warned today
func (q *Queries) UpdateWarningNotifiedAt(ctx context.Context, arg UpdateWarningNotifiedAtParams) error {
	_, err := q.db.ExecContext(ctx, updateWarningNotifiedAt, arg.UserID, arg.GuildID, arg.WarningNotifiedAt)
	return err
}
